# Project Title

A short description of your project and its purpose.

### Day 51 (JS)

```js
async function getData() {
  return await Promise.resolve("👦");
}

const data = getData();
console.log(data);
data.then((res) => console.log({ res }));
```

### Day 52 (JS)

```js
const { fName: feDev } = { fName: "Mr.X" };

// as we are also renaming the key after extracting it in a variable so fName will not exist and we get an error of referenceError: fName is not defined
console.log(fName);
```

### Day 53 (JS)

```js
function sum(n1, n2 = n1) {
  console.log(n1 + n2);
}

sum(10);
sum(10, 50);
```

### Day 54 (JS)

```js
let newList = [2, 3].push(4); // 3
// We will get an error typeError as this method does not exist because push method returns the updated length of the array not the array
console.log(newList.push(5));
```

### Day 55 (JS)

```js
// We will get an error of syntaxError because Rest parameter must be last formal parameter
function getItems(list, ...args, moreItem){
    return [...list, ...args, moreItem];
}

getItems(["berry", "apple"], "pear", "kiwi");
```

### Day 56 (JS)

```js
function nums(a, b) {
  if (a > b) console.log("a is large");
  else console.log("b is large");
  return;
  a + b;
}
// because if we do not add ; to a return statement like above
// js compiler automatically add it before execution.
//output :
/*
a is large
undefined
b is large
undefined
*/
console.log(nums(4, 2));
console.log(nums(1, 2));
```

### Day 57 (JS)

```js
class Person {
  constructor() {
    this.name = "Diana";
  }
}

Person = class AnotherPerson {
  constructor() {
    this.name = "Lady";
  }
};

const member = new Person();
// output: Lady
// this behavior is normal in javascript we can reassign a class to another class through class or function constructor
console.log(member.name);
```

### Day 58 (JS)

```js
const fullName = "Sehar Zehar";
// We will get a typeError that fullName is not a function with any datatype.
console.log(fullName());
```

### Day 59 (JS)

```js
let fName = "Sehar";
function getName() {
  console.log(fName);
  let fName = "Zehar";
}

getName();
```

### Day 60 (JS)

```js
// one = {} because {} is a truthy value
const one = false || {} || null;
// two = "" because it is left on the left side of the short circuiting.
const two = null || false || "";
// three = [] because boolean([]) is true
const three = [] || 0 || true;
// output: {} '' []
console.log(one, two, three);
```

### Day 61 (JS)

```js
console.log(`${((x) => x)("I love")} JS`);
// output: I love JS

// There is an IFFE in the console log which passes "I love" into x which it the function and it returns it.
```

### Day 62 (JS)

```js
let num = 1;
const list = ["🥳", "🤠", "🤗"];

// output: 🤗
// num+=1  => num=num+1
console.log(list[(num += 1)]);
```

### Day 63 (JS)

```js
let randomValue = { name: "naina" };
randomValue = 23;

if (!typeof randomValue === "string") {
  console.log("It's not a string!");
} else {
  console.log("Yay it's a string!");
}

// output: "Yay it's a string"
// !typeof randomValue === "string"
// !typeof 23 === "string"
// !"number" === "string"
// false === "string"  resulting in false
```

### Day 64 (JS)

```js
const animals = {};
let dog = { emoji: "🐶" };
let cat = { emoji: "🐈" };
// because when ever we assign an object as a key in an object it gets converted to object Object
animals[dog] = { ...dog, name: "Dug" };
// animals {[object Object]: {emoji: "🐶", name: "Dug"}}
animals[cat] = { ...cat, name: "Bux" };
// animals {[object Object]: {emoji: "🐈", name: "Bux"}}

console.log(animals[dog]);
```

### Day 65 (JS)

```js
const user = {
  email: "abc@domain.com",
  updateEmail: (email) => {
    this.email = email;
  },
  updateEmailSimple: function (email) {
    this.email = email;
  },
};
// as we know that arrow function this is of that of its parent and in this case its window object so on window.email = 'latest@email.in'
user.updateEmail("latest@email.in");
console.log(user.email);
console.log(window.email);

user.updateEmailSimple("latest@email.in");
console.log(user.email);
```

### Day 66 (JS)

```js
const fruit = ["🍌", "🍊", "🍎"];

fruit.slice(0, 1);
fruit.splice(0, 1);
fruit.unshift("🍇");

console.log(fruit);
// output: ["🍇", "🍊", "🍎"]
```

### Day 67 (JS)

```js
let count = 0;
const nums = [0, 1, 2, 3];

nums.forEach((num) => {
  if (num) {
    count += 1;
  }
});

console.log(count);
```

### Day 68 (JS)

```js
const person = {
  name: "Mashal",
  address: {
    city: "Lahore",
  },
};

Object.freeze(person);
// Object.freeze only freezes the object at level 1 only mean shallow freeze
person.name = null;
person.address.city = null;

// {name: "Mashal", address: {city: null}}
console.log(person);
```

### Day 69 (JS)

```js
const person = {
  name: "Sehar",
};

Object.seal(person);
// seal method only allows modification, no deletion and addition

person.name = "Zehar";
person.skill = "JS";

delete person.name;

// output: {name: "Zehar"}
console.log(person);
```

### Day 70 (JS)

```js
const handler = {
  set: (target, property, value) =>
    console.log("Added a new property!", target, property, value),
  get: (target, property) =>
    console.log("Accessed a property!", target, property),
};

const person = new Proxy({}, handler);
// proxy object is used to detect change in objects, that change is addition of key, modification of key and getting value of key

person.name = "Aahmad";
person.name;
```

### Day 71 (JS)

```js
const MESSAGE = 108;

function getInfo() {
  // output: ReferenceError: Cannot access MESSAGE because it is not hoisted due to TDZ
  console.log(MESSAGE);
  const MESSAGE = "sadpanda";
}

getInfo();
```

### Day 72 (JS)

```js
const pets = ["🐶", "🦉"];

// with the help of these round/moon brackets it is converted to a expression otherwise it would be an invalid code.
({ item: pets[2] } = { item: "🐼" });

// output: ['🐶', '🦉', '🐼']
console.log(pets);
```

### Day 73 (JS)

```js
const FOO = "Aahmad";

// typeof FOO will return 'string'
// !typeof FOO will return false

// output: false
console.log(!typeof FOO == "object");
// output: false
console.log(!typeof FOO == "string");
```

### Day 74 (JS)

```js
const myFunc = ({ x, y, z }) => {
  console.log(x, y, z);
};
// 2 and 3 will be discarded as we are expecting only one argument which is an object,
// this is how javascript will be interpreting it
// const {x,y,z} = 1; this will result in the following line
// output: undefined undefined undefined
myFunc(1, 2, 3);
```

### Day 75 (JS)

```js
const add = (x) => (y) => (z) => {
  console.log(x, y, z);
  return x + y + z;
};

/*
concept of currying is used.
The above function is equal to this
const add = function(x){
    return function(y){
        return function(z){
            console.log(x,y,z);    
            return x+y+z;
        }
    }
}
*/

// output: 10,20,30
add(10)(20)(30);
```

### Day 76 (JS)

```js
const groceries = ["🍎", "🍇"];

if (groceries.indexOf("🍎")) {
  console.log("We have 🍎!");
} else {
  console.log(`We don't have 🍎!`);
}
// output: We don't have 🍎!
// because groceries.indexOf("🍎") will return 0 and it boolean value is false
```

### Day 77 (JS)

```js
const obj = { name: "JS" };
obj.ref = obj;

const str = JSON.stringify(obj);

console.log(str);

// This is due to the fact that obj is refering to itself producing a cyclic dependency. Which cannot be stringify.
// output: TypeError: COnverting circular structure to JSON
```

### Day 78 (JS)

```js
var magic = 900;
function magic() {
  console.log("magic");
}
// output: 900
console.log(magic);

// In JS function declaration is prioritize so if I break down my code in terms how javascript will see it.

/* 
function magic(){
    console.log("magic");
}
var magic;

magic = 900;

console.log(magic);

*/
```

### Day 79 (JS)

```js
const array = [{ key: "J" }, "2", "X"];

// delete does delete the entry from the array but it adds an empty slot in its place
delete array[0];

// output: 3 [empty, '2', 'X']
console.log(array.length, array);
```

### Day 80 (JS)

```js
let z = (a = {});

a.name = "JS";
// as a and z are pointing to the same object
// a={}
// let z = a
// output: JS
console.log(z.name);
```

### Day 81 (JS)

```js
function task() {
  return new Promise((res) => {
    res("data");
  });
}

const result = task().then();

console.log(result);
```

### Day 82 (JS)

```js
console.log(1);

// new Promise(function (res) {
//   console.log(2);
// });

// output
// 1
// 2
// 3
// Because Promise constructor invokes the function by default.
// to fix this

function task() {
  return new Promise(function (res) {
    console.log(2);
  });
}

console.log(3);
```

### Day 83 (JS)

```js
const dataMap = new WeakMap();

let person = { name: "JS" };

dataMap.set(person, "TVA");

console.log(dataMap.get(person));
person = null;
console.log(dataMap.get(person));

/* 
output:
TVA
undefined
A WeakMap in JavaScript is a collection of key/value pairs where the keys must be objects and are held "weakly." This means that if there are no other references to a key object besides the one in the WeakMap, that object is eligible for garbage collection. When a key object is garbage collected, its corresponding entry in the WeakMap is automatically removed. 
*/
```

### Day 84 (JS)

```js
var foo = function test() {
  console.log("inside test");
  // we can only access this test function inside not outside
};

test();

// ReferenceError: test is not defined.
```

### Day 85 (JS)

```js
againTest();
test();

// function expression
// cannot be accessed before initialization
var test = function () {
  console.log("inside test");
};

// function declaration or function statement
// can be accessed before initialization.
function againTest() {
  console.log("againTest test");
}

/* 
output: 
againTest test
Uncaught TypeError: test is not a function
*/
```

### Day 86 (JS)

```js
const data1 = ["C", "B", "A"];
const data2 = ["Z", "Y", "X"];

// this method is introduced in ECMA script 2023 it does not sort the original array but returns a new array which is sorted
const data3 = data1.toSorted();
// sort method sort the original array and returns a reference to the array like the original array is return.
data2.sort();

console.log({ data1 });
console.log({ data2 });
```

### Day 87 (JS)

```js
const data1 = ["C", "B", "A"];
const data2 = ["Z", "Y", "X"];

// toReversed only returns a reversed array but does not change the original array
data1.toReversed();
// reverse method mutates the array and returns the actual array which is mutated.
data2.reverse();

console.log({ data1 });
console.log({ data2 });

// output

// {data1:["C", "B", "A"]}
// {data2:["X", "Y", "Z"]}
```

### Day 88 (JS)

```js
const arr = [, , ,];

console.log(arr.length);

// output
// 3
// because arr has [empty x 3]
// arr[0] will give undefined
// this type of array in javascript is called a sparse array in short an array which contains some empty items.
```

### Day 89 (JS)

```js
let x = 10;
let y = "A";
[x, y] = [y, x];

console.log({ x, y });

// output
// {x:'A', y:10}
```

### Day 90 (JS)

```js
// execution will happen from left to right so typeof y will return undefined but typeof x will generate reference error
let x = [typeof x, typeof y];
// but if we use var instead of let then the output will be [undefined, undefined]
console.log(x);

// output
// Uncaught ReferenceError: Cannot access 'x' before initialization
```

### Day 91 (JS)

```js
const [x, ...y] = [1, 2, 3, 4];

console.log({ x, y });

// output
// {x:1, y:[2,3,4]}
```

### Day 92 (JS)

```js
var age = 99;

console.log(window.age);
// output
// 99
```

### Day 93 (JS)

```js
let name = "JS";

name[0] = "R";
name[1] = "X";

console.log(name);
// output
// JS
// strings are immutable
```

### Day 94 (JS)

```js
let str = new String("JS");

console.log(str === "JS");

console.log(str == "JS");

// output
// false
// true
// because typeof str returns object
// in simple == comparison non primitive data type is converted into primitive
```

### Day 95 (JS)

```js
const obj = {};

obj[(obj["A"] = "B")] = "C";

console.log(obj);
// output
// {A: 'B', B: 'C'}
// obj['A']='B' will return 'B' as a string
// obj['A']='B'; const key = obj['A']; obj[key]='C';
```

### Day 96 (JS)

```js
// 5 ways to create an Object
const obj1 = {};
const obj2 = new Object();
const obj3 = Object.assign({}, {});
const obj4 = Object.create({});
function test() {}
const obj5 = new test();
console.log(obj1, obj2, obj3, obj4, obj5);
// output
// {}[[Prototype]]: Object {} {} {} test {}[[Prototype]]: Object
```

### Day 97 (JS)

```js
// function test() {
//   for (var i = 0; i < 5; i++) {
//     setTimeout(function () {
//       console.log(i);
//     }, 100);
//   }
// }

// test();

// output
// 5
// 5
// 5
// 5
// 5

// solution 1

// function test() {
//   for (let i = 0; i < 5; i++) {
//     setTimeout(function () {
//       console.log(i);
//     }, 100);
//   }
// }

// test();

// solution 2

function test() {
  for (let i = 0; i < 5; i++) {
    (function (val) {
      setTimeout(function () {
        console.log(i);
      }, 100);
    })(i);
  }
}

test();
```

### Day 98 (JS)

```js
const arr = [1, 2, 3];

console.log(arr[5]);
// output
// undefined
// The reason we got undefined is that everything in JS is an object in the above code we are not accessing the 5th address but a key
```

### Day 99 (JS)

```js
function init(x, y, z) {}

function end(a, b = 0, c) {}

console.log(init.length);
console.log(end.length);

// output
// 3
// 1

// In JS a function length is equal to its arguments when we assign a default value to its argument it is exlcuded from the length of function and all the arguments coming after it are also exluded.
```

### Day 100 (JS)

```js
const Person = {
  lang: "JS",
  show: function () {
    console.log(`Hi,${this.lang}`);
  },
};

let fn = Person.show;
fn();

// output

// Hi,undefined
// because fn() is getting called in windows context not in Person Object context

// to resolve this issue we can
fn.call(Person);
// output
// Hi,JS
// or another solution
Person.show();
// output
// Hi,JS
```
